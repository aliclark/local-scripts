#!/usr/bin/python

import string
import os
import sys
import subprocess
import urllib
from xml.dom.minidom import parseString
from HTMLParser import HTMLParser


#
# Implemented
# -----------
# jirate issue SA-1234
# jirate issuexml SA-1234
# jirate approve SA-1234 [comment]
#
# In scope
# --------
# jirate investigate SA-1234 [comment]
# jirate investigatd SA-1234 [comment]
# jirate implement SA-1234 [comment]
# jirate implemented SA-1234 [comment]
# jirate disapprove SA-1234 [comment]
#
# jirate comment SA-1234 comment
#
# jirate attach SA-1234 filepath|URL [comment]
#
# jirate webcreate SA  (opens URL for creating issues in web browser)
#
# jirate filter 'My Active Issues' [-n 10]
# jirate filterxml 'My Active Issues' [-n 10]
#
# jirate post URL postdata  (performs login, then does POST request)
#
# jirate help
# jirate *anything else* -> jirate help
#
# Not in scope
# ------------
# jirate create SA (opens editor for editing an "issue spec")
# jirate update SA-1234 description 'bug description'
#

# Todo
# ----
# > Support for multiple version and fixVersions
# > Error handling
# > Test for login
# > Use urllib instead of wget
# > Store cookies in user directory
# > "Not modified" cacheing
# > Work out fixVersions id

jiratePath = '~/.jirate'
jirateCookiePath = jiratePath + '/cookies.txt'

jiraPath = None
jiraUser = None
jiraPass = None

# TODO: programmatically determine these values
versionIds = { 'jade': '10954' }
activeId = '10041'

# Not sure what this is
activeTempMax = '1000'

loginUrl     = None
activeXmlUrl = None

approveAction    = '161'
disapproveAction = '171'

fixedResolution = '1'

loggedIn = False


### Library code

def pad(s, n):
    rv = s
    while len(rv) < n:
        rv += ' '
    return rv

def lookor(h, k, v):
    try:
        return h[k]
    except:
        return v

def fail(m):
    print m
    sys.exit(1)


class MLStripper(HTMLParser):
    def __init__(self):
        self.reset()
        self.fed = []
    def handle_data(self, d):
        self.fed.append(d)
    def get_data(self):
        return ''.join(self.fed)

def strip_tags(html):
    s = MLStripper()
    s.feed(html)
    return s.get_data()

def tidyData(x):
    return strip_tags(string.replace(x, '<br/>\n', '')).trim()


# Adding contraints and unwrapping of data lists

def checkCount(minN=None, maxN=None):
    def checker(x, s='value'):
        l = len(x)

        if minN != None and l < minN:
            fail(s + ': has ' + l + ' items, should have minimum ' + minN)

        if maxN != None and l > maxN:
            fail(s + ': has ' + l + ' items, should have maximum ' + maxN)

        if maxN in [0, 1]:
            if l == 0:
                return None
            return x[0]

        return x

    return checker

zero       = checkCount(0, 0)
optional   = checkCount(0, 1)
one        = checkCount(1, 1)
oneToMany  = checkCount(1)


def removeEmpties(l):
    return filter(lambda x: x != '', l)


### Low level procedures to GET and POST data

def doLogin(continueTo=None):
    global loggedIn

    return subprocess.Popen(["wget", "-q", "-O", "-", "--save-cookies", jirateCookiePath, "--keep-session-cookies", "--post-data='os_username=" + jiraUser + "&os_password=" + jiraPass + "&os_cookie=true'", loginUrl], stdout=subprocess.PIPE).communicate()[0]

def doPost(url, post):
    global loggedIn

    # try the post action

    if failed:
        doLogin()
        # repeat the post action attempt one more time
    else:
        return value

    p = subprocess.Popen("wget -q -O - --load-cookies " + jirateCookiePath + " --post-data='" + post + "' " + url + " >/dev/null 2>/dev/null", shell=True)
    sts = os.waitpid(p.pid, 0)[1]

def getPage(url):
    global loggedIn

    if not loggedIn:
        return doLogin(url)
    else:
        rv = subprocess.Popen(["wget", "-q", "-O", "-", "--load-cookies", jirateCookiePath, url], stdout=subprocess.PIPE).communicate()[0]
        if False:
            return doLogin(url)
        return rv


### Higher level data getters

def getIssueXml(j):
    return getPage(jiraPath + "/si/jira.issueviews:issue-xml/" + j + "/" + j + ".xml")

def getActiveXml():
    return getPage(activeXmlUrl)


### Low level data item getters

def xmlDocItems(doc):
    return doc.getElementsByTagName('item')

def xmlItems(s):
    return xmlDocItems(parseString(s))

def getIssueDocItem(j):
    return one(xmlItems(getIssueXml(j)))


### Higher level data item getters

def dataItems(item, tag, attr=None):
    rv = []
    nodes = item.getElementsByTagName(tag)
    node = None
    chNode = None
    value = ''

    for i in range(len(nodes)):
        node = nodes[i]
        if attr != None:
            rv.append(node.getAttribute(attr))
        else:
            if len(node.childNodes) != 1:
                fail(tag + ' has too many childNodes')

            chNode = node.childNodes[0]

            if chNode.nodeType != chNode.TEXT_NODE:
                fail(tag + ' child is not a text node')

            value = tidyData(chNode.data)

            if value != '':
                rv.append(value)

    return rv

def getDocItemKeyId(i):
    return one(dataItems(i, 'key', 'id'))


### Converting data item values to fancy string representations

def dataLines(item, k, n=0, useTabs=False):

    def dataLine(l):
        if useTabs:
            t = '\t'
        else:
            t = ' '
        return pad(k + ':', n + 1)  + t + l

    datas = dataItems(item, k)
    return '\n'.join(map(dataLine, datas))

def issueTagLine(item, fullp):
    outer = []
    tags = [ 'key', 'type', 'priority', 'status' ]

    if fullp:
        tags.append('resolution')

    if fullp:
        joins = ' '
    else:
        joins = '\t'

    def tagVal(t): return optional(dataItems(item, t))
    def tagStr(t): return pad('[' + data + ']', maxn + 2)

    innerVals = map(tagVal, tags)
    innerValsLeft = removeEmpties(innerVals)
    maxn = max(map(len, innerValsLeft))

    outer.append(joins.join(map(tagStr, innerValsLeft)))

    summary = optional(dataItems(item, 'summary'))
    if summary != None:
        outer.append(summary)

    return '\t'.join(outer)

def issueSmallTagLine(item):
    return issueTagLine(item, False)

def issueFullTagLine(item):
    return issueTagLine(item, True)

def issueOneLinerFields(item):
    lines = [
        'component',
        'due',
        'version', 'fixVersion',
        'reporter', 'assignee',
        'created', 'updated'
        'environment'
        ]
    maxn = max(map(len, lines))

    def getLines(li):
        return dataLines(item, li, maxn)

    vals = map(getLines, lines)
    valsLeft = removeEmpties(vals)

    return '\n'.join(valsLeft)

def issueDescriptionPart(item):
    tag = 'description'
    tmp = optional(dataItems(item, tag))

    if tmp == None:
        return ''

    return tag + ':\n' + tmp

def issueCommentsPart(item):
    tag = 'comment'
    comments = item.getElementsByTagName(tag)

    def getComment(comment):
        return ('[' + tag + ' author: "' + comment.getAttribute('author') + '", created: "' + comment.getAttribute('created') + '"]\n' +
                tidyData(comment.childNodes[0].data))

    return '\n\n'.join(map(getComment, comments))


### Full data page builders

def getIssueEssentials(j):
    item = getIssueDocItem(j)
    s = None
    getters = [issueFullTagLine, issueOneLinerFields, issueDescriptionPart, issueCommentsPart]
    parts = map(lambda f: f(item), getters)
    partsLeft = removeEmpties(parts)

    if len(partsLeft) == 0:
        return ''

    s = '\n\n'.join(partsLeft)
    return '\n' + s + '\n'

def getActiveTitles():
    items = xmlItems(getActiveXml())
    return '\n'.join(map(issueSmallTagLine, items))


### Post actions

def issueApproved(j, comment):

    def getFixVersionId(f):
        v = lookor(versionIds, f, None)
        if v == None:
            fail('Unknown fixVersion ' + f + ' - please insert the id in the versionIds table')
        return v

    # first we get the page so we know the issue id
    item  = getIssueDocItem(j)
    keyId = getDocItemKeyId(getIssueDocItem(j))

    fixVs = dataItems(item, 'fixVersion')

    # If we aren't able to lookup the IDs of every single fixVersion, we should fail
    fixVids = map(getFixVersionId, fixVs)

    if len(fixVids) != 1:
        fail('FIXME: script currently doesn\'t know what to do when number of fixVersions is not 1.\n' +
             'please fix the code and submit it to maintainer')

    post = 'resolution=1&fixVersions=' + ','.join(fixVids) + '&assignee=' + jiraUser + '&comment=' + urllib.quote(comment, '') + '&commentLevel=&action=' + approveAction + '&id=' + keyId + '&viewIssueKey=&Approved=Approved'

    doPost(jiraPath + '/secure/CommentAssignIssue.jspa', post)

def issueDisapproved(j, comment):

    # first we get the page so we know the issue id
    item  = getIssueDocItem(j)
    keyId = getDocItemKeyId(getIssueDocItem(j))

    assignee = ''

    # need to fix assignee

    post = 'assignee=' + assignee + '&comment=' + urllib.quote(comment, '') + '&commentLevel=&action=' + disapproveAction + '&id=' + keyId + '&viewIssueKey=&Disapproved=Disapproved'

    print post
    return

    doPost(jiraPath + '/secure/CommentAssignIssue.jspa', post)


### Turn the arguments into some kind of data request / post

def getOutput():
    rv = ''
    action = lookor(sys.argv, 1, 'noop')

    if action == 'noop':
        rv = ''
    elif action == 'issue':
        rv = getIssueEssentials(sys.argv[2])
    elif action == 'issuexml':
        rv = getIssueXml(sys.argv[2])
    elif action == 'active':
        rv = getActiveTitles()
    elif action == 'approve':
        issueApproved(sys.argv[2], lookor(sys.argv, 3, ''))
    elif action == 'approve':
        issueDisapproved(sys.argv[2], lookor(sys.argv, 3, ''))

    return rv

def main():
    global jiraPath, jiraUser, jiraPass
    global loginUrl, activeXmlUrl

    jiraPath = os.environ['JIRATE_HOST']
    jiraUser = os.environ['JIRATE_USER']
    jiraPass = os.environ['JIRATE_PASS']

    loginUrl     = jiraPath + '/login.jsp'
    activeXmlUrl = jiraPath + "/sr/jira.issueviews:searchrequest-xml/" + activeId + "/SearchRequest-" + activeId + ".xml?tempMax=" + activeTempMax

    if not os.path.isdir(jiratePath):
        os.mkdir(jiratePath, 0700)

    if not os.path.isfile(jirateCookiePath):
        open(jirateCookiePath, 'w').close()
    os.chmod(jiraCookiePath, stat.S_IREAD | stat.S_IWRITE)

    text = getOutput()

    if text != '':
        print text

main()
