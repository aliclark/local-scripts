#!/usr/bin/python

import string
import os
import sys
import subprocess
import urllib
import stat
from xml.dom.minidom import parseString
from HTMLParser import HTMLParser

# Todo
# ----
# > Support for multiple version and fixVersions
# > Error handling
# > Try action before doing login
# > Use urllib instead of wget
# > "Not modified" cacheing
# > Work out fixVersions id
# > Ensure actions are properly escaped, especially for 'post' and 'filter'

jiratePath = os.path.expanduser('~/.jirate')
jirateCookiePath = jiratePath + '/cookies.txt'

jiraPath = None
jiraUser = None
jiraPass = None

# TODO: programmatically determine these values
versionIds = { 'jade': '10954' }
activeId = '10041'

# Not sure what this is
activeTempMax = '1000'

loginUrl     = None
activeXmlUrl = None

approveAction    = '161'
disapproveAction = '171'

fixedResolution = '1'

loggedIn = False

envExamples = {
    'JIRATE_HOST': 'http://jira',
    'JIRATE_USER': 'john.smith',
    'JIRATE_PASS': 'hunter2'
    }


### Library code

def pad(s, n):
    rv = s
    while len(rv) < n:
        rv += ' '
    return rv

def lookor(h, k, v):
    try:
        return h[k]
    except:
        return v

def fail(m):
    print m
    sys.exit(1)


class MLStripper(HTMLParser):
    def __init__(self):
        self.reset()
        self.fed = []
    def handle_data(self, d):
        self.fed.append(d)
    def get_data(self):
        return ''.join(self.fed)

def strip_tags(html):
    s = MLStripper()
    s.feed(html)
    return s.get_data()

def tidyData(x):
    return strip_tags(string.replace(x, '<br/>\n', '')).trim()


# Adding contraints and unwrapping of data lists

def checkCount(minN=None, maxN=None):
    def checker(x, s='value'):
        l = len(x)

        if minN != None and l < minN:
            fail(s + ': has ' + l + ' items, should have minimum ' + minN)

        if maxN != None and l > maxN:
            fail(s + ': has ' + l + ' items, should have maximum ' + maxN)

        if maxN in [0, 1]:
            if l == 0:
                return None
            return x[0]

        return x

    return checker

zero       = checkCount(0, 0)
optional   = checkCount(0, 1)
one        = checkCount(1, 1)
oneToMany  = checkCount(1)


def removeEmpties(l):
    return filter(lambda x: x != '', l)


### Low level procedures to GET and POST data

def doLogin(continueUrl=None):
    return subprocess.Popen(["wget", "-q", "-O", "-", "--save-cookies", jirateCookiePath, "--keep-session-cookies", "--post-data='os_username=" + jiraUser + "&os_password=" + jiraPass + "&os_cookie=true'", loginUrl], stdout=subprocess.PIPE).communicate()[0]

def doPost(url, post):
    global loggedIn

    if not loggedIn:
        loggedIn = True
        doLogin()

    p = subprocess.Popen("wget -q -O - --load-cookies " + jirateCookiePath + " --post-data='" + post + "' " + url + " >/dev/null 2>/dev/null", shell=True)
    sts = os.waitpid(p.pid, 0)[1]

def getPage(url):
    global loggedIn

    if not loggedIn:
        loggedIn = True
        return doLogin()

    return subprocess.Popen(["wget", "-q", "-O", "-", "--load-cookies", jirateCookiePath, url], stdout=subprocess.PIPE).communicate()[0]


### Higher level data getters

def getIssueXml(j):
    return getPage(jiraPath + "/si/jira.issueviews:issue-xml/" + j + "/" + j + ".xml")

def getActiveXml():
    return getPage(activeXmlUrl)


### Low level data item extraction

def xmlDocItems(doc):
    return doc.getElementsByTagName('item')

def xmlItems(s):
    return xmlDocItems(parseString(s))

def getIssueDocItem(j):
    return one(xmlItems(getIssueXml(j)))


### Higher level data item extraction

def dataItems(item, tag, attr=None):
    rv = []
    nodes = item.getElementsByTagName(tag)
    node = None
    chNode = None
    value = ''

    for i in range(len(nodes)):
        node = nodes[i]
        if attr != None:
            rv.append(node.getAttribute(attr))
        else:
            if len(node.childNodes) != 1:
                fail(tag + ' has too many childNodes')

            chNode = node.childNodes[0]

            if chNode.nodeType != chNode.TEXT_NODE:
                fail(tag + ' child is not a text node')

            value = tidyData(chNode.data)

            if value != '':
                rv.append(value)

    return rv

def getDocItemKeyId(i):
    return one(dataItems(i, 'key', 'id'))


### Converting data item values to fancy string representations

def dataLines(item, k, n=0, useTabs=False):

    def dataLine(l):
        if useTabs:
            t = '\t'
        else:
            t = ' '
        return pad(k + ':', n + 1)  + t + l

    datas = dataItems(item, k)
    return '\n'.join(map(dataLine, datas))

def issueTagLine(item, fullp):
    outer = []
    tags = [ 'key', 'type', 'priority', 'status' ]

    if fullp:
        tags.append('resolution')

    if fullp:
        joins = ' '
    else:
        joins = '\t'

    def tagVal(t): return optional(dataItems(item, t))
    def tagStr(t): return pad('[' + data + ']', maxn + 2)

    innerVals = map(tagVal, tags)
    innerValsLeft = removeEmpties(innerVals)
    maxn = max(map(len, innerValsLeft))

    outer.append(joins.join(map(tagStr, innerValsLeft)))

    summary = optional(dataItems(item, 'summary'))
    if summary != None:
        outer.append(summary)

    return '\t'.join(outer)

def issueSmallTagLine(item):
    return issueTagLine(item, False)

def issueFullTagLine(item):
    return issueTagLine(item, True)

def issueOneLinerFields(item):
    lines = [
        'component',
        'due',
        'version', 'fixVersion',
        'reporter', 'assignee',
        'created', 'updated'
        'environment'
        ]
    maxn = max(map(len, lines))

    def getLines(li):
        return dataLines(item, li, maxn)

    vals = map(getLines, lines)
    valsLeft = removeEmpties(vals)

    return '\n'.join(valsLeft)

def issueDescriptionPart(item):
    tag = 'description'
    tmp = optional(dataItems(item, tag))

    if tmp == None:
        return ''

    return tag + ':\n' + tmp

def issueCommentsPart(item):
    tag = 'comment'
    comments = item.getElementsByTagName(tag)

    def getComment(comment):
        return ('[' + tag + ' author: "' + comment.getAttribute('author') + '", created: "' + comment.getAttribute('created') + '"]\n' +
                tidyData(comment.childNodes[0].data))

    return '\n\n'.join(map(getComment, comments))


### Full page outputs of fancy data strings

def getIssueEssentials(j):
    item = getIssueDocItem(j)
    s = None
    getters = [issueFullTagLine, issueOneLinerFields, issueDescriptionPart, issueCommentsPart]
    parts = map(lambda f: f(item), getters)
    partsLeft = removeEmpties(parts)

    if len(partsLeft) == 0:
        return ''

    s = '\n\n'.join(partsLeft)
    return '\n' + s + '\n'

def getActiveTitles():
    items = xmlItems(getActiveXml())
    return '\n'.join(map(issueSmallTagLine, items))


### Post actions

def issueApproved(j, comment):

    def getFixVersionId(f):
        v = lookor(versionIds, f, None)
        if v == None:
            fail('Unknown fixVersion ' + f + ' - please insert the id in the versionIds table')
        return v

    # first we get the page so we know the issue id
    item  = getIssueDocItem(j)
    keyId = getDocItemKeyId(getIssueDocItem(j))

    fixVs = dataItems(item, 'fixVersion')

    # If we aren't able to lookup the IDs of every single fixVersion, we should fail
    fixVids = map(getFixVersionId, fixVs)

    if len(fixVids) != 1:
        fail('FIXME: script currently doesn\'t know what to do when number of fixVersions is not 1.\n' +
             'please fix the code and submit it to maintainer')

    post = 'resolution=1&fixVersions=' + ','.join(fixVids) + '&assignee=' + jiraUser + '&comment=' + urllib.quote(comment, '') + '&commentLevel=&action=' + approveAction + '&id=' + keyId + '&viewIssueKey=&Approved=Approved'

    doPost(jiraPath + '/secure/CommentAssignIssue.jspa', post)

def issueDisapproved(j, comment):

    # first we get the page so we know the issue id
    item  = getIssueDocItem(j)
    keyId = getDocItemKeyId(getIssueDocItem(j))

    assignee = ''

    # need to fix assignee

    post = 'assignee=' + assignee + '&comment=' + urllib.quote(comment, '') + '&commentLevel=&action=' + disapproveAction + '&id=' + keyId + '&viewIssueKey=&Disapproved=Disapproved'

    print post
    return

    doPost(jiraPath + '/secure/CommentAssignIssue.jspa', post)


### Help text creation

def commandExample(c):
    if c == None:
        return '\n'
    if c[1] == '':
        return c[0] + '\n'
    return c[0] + '\n\n\t' + c[1] + '\n\n'

def getHelpText(problem):

    commands = [
        ('jirate issue    $issue',
         'Prints a simple data output for the issue'),
        ('jirate issuexml $issue',
         'Prints the RSS XML for the issue'),
        ('jirate approve     $issue [$comment]',
         'Approve the issue, optionally supplying a comment')
        ]
    commandsTodo = [
        ('jirate investigate $issue [$comment]', ''),
        ('jirate investigatd $issue [$comment]', ''),
        ('jirate implement   $issue [$comment]', ''),
        ('jirate implemented $issue [$comment]', ''),
        ('jirate disapprove  $issue [$comment]', ''),
         None,
        ('jirate comment $issue $comment', ''),
        ('jirate attach  $issue ($filepath | $url) [$comment]', ''),
         None,
        ('jirate filter    $filter [-n 10]', ''),
        ('jirate filterxml $filter [-n 10]', ''),
         None,
        ('jirate webcreate $project  (opens URL for creating issues in web browser)', ''),
        ('jirate post $url $postdata  (performs login, then does POST request)', '')
        ]
    commandsOutOfScope = [
        ('jirate create $project (opens editor for editing an "issue spec")', ''),
        ('jirate update $issue $field $value', '')
        ]

    problemStr = ''
    if problem != None:
        problemStr = '\nProblem: ' + problem + '\n'

    return (problemStr + '\n\tjirate help\n\n'
            'jirate is a command-line tool to interface with JIRA.\n'
            'It is not intended to cover all uses of JIRA, but to perform common tasks simply and efficiently.\n'
            'Therefore this script will not completely replace your current method of using JIRA,\n'
            'but should reduce it to sane levels of usage.\n'
            'For a more complete JIRA command line tool, try the JIRA Command Line Interface.\n\n'
            'USAGE:\n\n' +
            ''.join(map(commandExample, commands)) + 
            '\nTODO:\n\n' +
            ''.join(map(commandExample, commandsTodo)) + 
            '\nOUT OF SCOPE:\n\n' +
            ''.join(map(commandExample, commandsOutOfScope)))


### Turn the arguments into some kind of data request / post

def getOutput():
    rv = ''
    problem = None
    action  = lookor(sys.argv, 1, None)
    argMins = {
        'issue': 1,
        'issuexml': 1,
        'active': 0,
        'approve': 1,
        'disapprove': 1,
        'post': 2
        }

    if action == None:
        action = 'help'
        problem = 'Please supply an action to perform'

    def enoughArgs(action):
        if (len(sys.argv) - 2) < argMins[action]:
            return False
        return True

    if (action in argMins) and not enoughArgs(action):
        problem = ('Not enough args supplied for action "' + action +
                   '" (you supplied ' + str(len(sys.argv) - 2) + ' but it needs ' + str(argMins[action]))
        action  = 'help'

    if action == 'issue':
        rv = getIssueEssentials(sys.argv[2])
    elif action == 'issuexml':
        rv = getIssueXml(sys.argv[2])
    elif action == 'active':
        rv = getActiveTitles()
    elif action == 'approve':
        issueApproved(sys.argv[2], lookor(sys.argv, 3, ''))
    elif action == 'disapprove':
        issueDisapproved(sys.argv[2], lookor(sys.argv, 3, ''))
    elif action == 'post':
        doPost(sys.argv[2], sys.argv[3])
    elif action == 'help':
        rv = getHelpText(problem)
    else:
        problem = 'Unknown command "' + action + '"'
        rv = getHelpText(problem)

    return rv


### Set up global variables for config items host, user, and pass

def envVarNotPresent(v):
    return not v in os.environ

def setupVars():
    global jiraPath, jiraUser, jiraPass
    global loginUrl, activeXmlUrl

    def makeExample(x):
        return 'eg. ' + x + '=' + envExamples[x]

    needed = ['JIRATE_HOST', 'JIRATE_USER', 'JIRATE_PASS']

    notFound = filter(envVarNotPresent, needed)

    if len(notFound) != 0:
        fail('Required environment variables not set: ' + ', '.join(notFound) +
             '\n' + '\n'.join(map(makeExample, notFound)))

    jiraPath = os.environ[needed[0]]
    jiraUser = os.environ[needed[1]]
    jiraPass = os.environ[needed[2]]

    loginUrl     = jiraPath + '/login.jsp'
    activeXmlUrl = jiraPath + "/sr/jira.issueviews:searchrequest-xml/" + activeId + "/SearchRequest-" + activeId + ".xml?tempMax=" + activeTempMax


### Setup up the cookie file

def setupDirs():
    if not os.path.isdir(jiratePath):
        os.mkdir(jiratePath, 0700)

    if not os.path.isfile(jirateCookiePath):
        open(jirateCookiePath, 'w').close()
    os.chmod(jirateCookiePath, stat.S_IREAD | stat.S_IWRITE)


def main():
    setupVars()
    setupDirs()

    text = getOutput()

    if text != '':
        print text

main()
